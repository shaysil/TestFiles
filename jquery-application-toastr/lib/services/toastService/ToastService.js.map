{"version":3,"sources":["services/toastService/ToastService.ts"],"names":[],"mappings":";;AACA,8CAAwE;AAexE,+DAA+D;AAC/D;IAAA;IAsPA,CAAC;IAjPA,yBAAyB;IACzB,gBAAgB;IAChB,yBAAyB;IAEzB,kEAAkE;IACpD,sBAAS,GAAvB,UAAwB,YAA0B,EAAE,OAAe,EAAE,KAAW;QAAhF,iBASC;QARA,MAAM,CAAC,IAAI,OAAO,CAAW,UAAC,OAAmC,EAAE,MAA4B;YAC9F,KAAI,CAAC,YAAY,CAAC,YAAY,EAAE,OAAO,EAAE,KAAK,CAAC;iBAC7C,IAAI,CAAC,UAAC,MAAgB;gBACtB,OAAO,CAAC,MAAM,CAAC,CAAC;YACjB,CAAC,CAAC,CAAC,KAAK,CAAC,UAAC,KAAU;gBACnB,MAAM,CAAC,KAAK,CAAC,CAAC;YACf,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACJ,CAAC;IAED;;MAEE;IACY,6BAAgB,GAA9B,UAA+B,EAAU,EAAE,KAAW;QACrD,IAAI,UAAU,GAAgB,YAAY,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAEhE,0DAA0D;QAC1D,0CAA0C;QAC1C,IAAI,KAAK,GAAW,YAAY,CAAC,sBAAsB,CAAC,EAAE,EAAE,UAAU,CAAC,aAAa,CAAC,CAAC;QACtF,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC;YAChB,UAAU,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,IAAI,IAAI,EAAE,CAAC;QAClD,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC;gBAC7B,EAAE,EAAE,EAAE;gBACN,GAAG,EAAE,IAAI,IAAI,EAAE;aACf,CAAC,CAAC;QACJ,CAAC;QACD,YAAY,CAAC,UAAU,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IAC5C,CAAC;IAGD,yBAAyB;IACzB,yBAAyB;IACzB,yBAAyB;IAEV,0BAAa,GAA5B,UAA6B,KAAW;QACvC,MAAM,CAAI,YAAY,CAAC,cAAc,SAAI,KAAO,CAAC;IAClD,CAAC;IAED,gFAAgF;IACjE,0BAAa,GAA5B,UAA6B,KAAW;QACvC,sEAAsE;QACtE,IAAI,UAAU,GAAgB,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC;QACrH,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YAChB,UAAU,CAAC,MAAM,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,iDAAiD;QAC7G,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,gCAAgC;YAChC,UAAU,GAAG;gBACZ,MAAM,EAAE,EAAE;gBACV,aAAa,EAAE,EAAE;aACjB,CAAC;QACH,CAAC;QACD,MAAM,CAAC,UAAU,CAAC;IACnB,CAAC;IAED,mDAAmD;IACpC,uBAAU,GAAzB,UAA0B,UAAuB,EAAE,KAAW;QAC7D,8CAA8C;QAC9C,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;YAClB,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC;QAC7E,CAAC;IACF,CAAC;IAGD,yBAAyB;IACzB,iBAAiB;IACjB,yBAAyB;IAEzB,4FAA4F;IAC7E,yBAAY,GAA3B,UAA4B,YAA0B,EAAE,OAAe,EAAE,KAAW;QACnF,MAAM,CAAC,IAAI,OAAO,CAAW,UAAC,OAAmC,EAAE,MAA4B;YAE9F,IAAI,UAAU,GAAgB,YAAY,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;YAEhE,EAAE,CAAA,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;gBACtB,wCAAwC;gBACxC,yDAAyD;gBACzD,IAAI,GAAG,GAAS,IAAI,IAAI,EAAE,CAAC;gBAC3B,IAAI,SAAS,GAAS,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,GAAC,KAAK,CAAC,CAAC;gBAEzD,EAAE,CAAC,CAAC,UAAU,CAAC,MAAM,GAAG,SAAS,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAC,CAAC;oBACtE,iDAAiD;oBACjD,OAAO,CAAC,YAAY,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC;oBAC/C,MAAM,CAAC;gBACR,CAAC;YACF,CAAC;YAED,EAAE,CAAC,CAAE,MAAc,CAAC,qBAAqB,CAAC,CAAC,CAAC;gBAC3C,6DAA6D;gBAC7D,MAAM,CAAC,UAAU,CAAC;oBACjB,YAAY,CAAC,YAAY,CAAC,YAAY,EAAE,OAAO,EAAE,KAAK,CAAC;yBACrD,IAAI,CAAC,UAAC,MAAgB;wBACtB,OAAO,CAAC,MAAM,CAAC,CAAC;oBACjB,CAAC,CAAC,CAAC;gBACL,CAAC,EAAE,GAAG,CAAC,CAAC;YACT,CAAC;YAAC,IAAI,CAAC,CAAC;gBACP,iEAAiE;gBACjE,6FAA6F;gBAC5F,MAAc,CAAC,qBAAqB,GAAG,IAAI,CAAC;gBAE7C,iDAAiD;gBACjD,YAAY,CAAC,iBAAiB,CAAC,YAAY,EAAE,OAAO,CAAC;qBACnD,IAAI,CAAC,UAAC,MAAgB;oBACtB,6CAA6C;oBAC7C,UAAU,CAAC,MAAM,GAAG,MAAM,CAAC;oBAC3B,UAAU,CAAC,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC,CAAC,yBAAyB;oBACzD,UAAU,GAAG,YAAY,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;oBAEnD,kBAAkB;oBAClB,YAAY,CAAC,UAAU,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;oBAE3C,wBAAwB;oBACvB,MAAc,CAAC,qBAAqB,GAAG,KAAK,CAAC;oBAE9C,uBAAuB;oBACvB,OAAO,CAAC,YAAY,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC;gBAChD,CAAC,CAAC,CAAC,KAAK,CAAC,UAAC,KAAU;oBACnB,MAAM,CAAC,KAAK,CAAC,CAAC;gBACf,CAAC,CAAC,CAAC;YACL,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAOD,uEAAuE;IACxD,8BAAiB,GAAhC,UAAiC,YAA0B,EAAE,OAAe;QAC3E,qDAAqD;QACrD,IAAI,GAAG,GAAW,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC;QAC3C,IAAI,MAAM,GAAW,4BAA0B,GAAG,oCAA+B,GAAG,OAAI,CAAC;QAEzF,MAAM,CAAC,YAAY,CAAC,GAAG,CAAI,OAAO,SAAI,YAAY,CAAC,WAAW,iBAAY,YAAY,CAAC,MAAM,iBAAY,MAAM,kBAAa,YAAY,CAAC,OAAS,EAAC,sBAAY,CAAC,cAAc,CAAC,EAAE,CAAC;aAChL,IAAI,CAAC,UAAC,QAA8B;YAEpC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;gBAClB,4DAA4D;gBAC5D,2DAA2D;gBAC3D,MAAM,0BAAwB,QAAQ,CAAC,MAAM,UAAK,QAAQ,CAAC,UAAU,MAAG,CAAC;YAC1E,CAAC;YAED,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;QACxB,CAAC,CAAC;aACD,IAAI,CAAC,UAAC,OAA0B;YAChC,2BAA2B;YAC3B,0EAA0E;YAC1E,iEAAiE;YACjE,mEAAmE;YACnE,IAAI,MAAM,GAAY,EAAE,CAAC;YACzB,GAAG,CAAC,CAAU,UAAa,EAAb,KAAA,OAAO,CAAC,KAAK,EAAb,cAAa,EAAb,IAAa;gBAAtB,IAAI,CAAC,SAAA;gBAET,MAAM,CAAC,IAAI,CAAC;oBACX,KAAK,EAAE,CAAC,CAAC,KAAK;oBACd,EAAE,EAAE,CAAC,CAAC,EAAE;oBACR,QAAQ,EAAE,CAAC,CAAC,QAAQ;oBACpB,SAAS,EAAE,CAAC,CAAC,SAAS;oBACtB,OAAO,EAAE,CAAC,CAAC,OAAO;oBAClB,OAAO,EAAE,CAAC,CAAC,OAAO,GAAC,aAAa;oBAChC,IAAI,EAAC,CAAC,CAAC,IAAI;iBACX,CAAC,CAAC;aACH;YACD,MAAM,CAAC,MAAM,CAAC;QACf,CAAC,CAAC,CAAC;IACL,CAAC;IAGD,yBAAyB;IACzB,kBAAkB;IAClB,yBAAyB;IAEzB,uFAAuF;IACxE,mCAAsB,GAArC,UAAsC,EAAU,EAAE,aAA6B;QAC9E,GAAG,CAAC,CAAC,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACvD,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC/B,MAAM,CAAC,CAAC,CAAC;YACV,CAAC;QACF,CAAC;QACD,MAAM,CAAC,CAAC,CAAC,CAAC;IACX,CAAC;IAED,4EAA4E;IAC7D,yBAAY,GAA3B,UAA4B,UAAuB;QAClD,6DAA6D;QAC7D,IAAI,SAAS,GAAa,EAAE,CAAC;QAC7B,GAAG,CAAC,CAAc,UAAiB,EAAjB,KAAA,UAAU,CAAC,MAAM,EAAjB,cAAiB,EAAjB,IAAiB;YAA9B,IAAI,KAAK,SAAA;YACb,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;SACzB;QAED,gEAAgE;QAChE,UAAU,CAAC,aAAa,GAAG,UAAU,CAAC,aAAa,CAAC,MAAM,CAAC,UAAC,KAAmB;YAC9E,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,UAAU,CAAC;IACnB,CAAC;IAED,mHAAmH;IACpG,yBAAY,GAA3B,UAA4B,UAAuB;QAClD,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,UAAC,KAAa;YAC7C,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;gBACpB,mEAAmE;gBACnE,uCAAuC;gBACvC,MAAM,CAAC,KAAK,CAAC;YACd,CAAC;YAED,IAAI,OAAO,GAAW,YAAY,CAAC,sBAAsB,CAAC,KAAK,CAAC,EAAE,EAAE,UAAU,CAAC,aAAa,CAAC,CAAC;YAC9F,EAAE,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC;gBAClB,IAAI,SAAS,GAAS,IAAI,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,yCAAyC;gBAC1H,MAAM,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;oBACzB,KAAK,MAAM;wBACV,eAAe;wBACf,MAAM,CAAC,KAAK,CAAC;oBACd,KAAK,QAAQ;wBACZ,MAAM,CAAC,IAAI,CAAC;oBACb;wBACC,kCAAkC;wBAClC,IAAI,GAAG,GAAS,IAAI,IAAI,EAAE,CAAC;wBAC3B,EAAE,CAAC,CAAC,GAAG,CAAC,WAAW,EAAE,KAAK,SAAS,CAAC,WAAW,EAAE;+BAC5C,GAAG,CAAC,QAAQ,EAAE,KAAK,SAAS,CAAC,QAAQ,EAAE;+BACvC,GAAG,CAAC,MAAM,EAAE,KAAK,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;4BAC1C,4CAA4C;4BAC5C,MAAM,CAAC,IAAI,CAAC;wBACb,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACP,qBAAqB;4BACrB,MAAM,CAAC,KAAK,CAAC;wBACd,CAAC;gBACH,CAAC;YACF,CAAC;YAAC,IAAI,CAAC,CAAC;gBACP,+CAA+C;gBAC/C,MAAM,CAAC,IAAI,CAAC;YACb,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IApPuB,2BAAc,GAAW,YAAY,CAAC,CAAC,2BAA2B;IAClE,8BAAiB,GAAY,KAAK,CAAC,CAAC,oBAAoB;IAoIhF,4EAA4E;IACpD,wBAAW,GAAW,0CAA0C,CAAC;IACjE,mBAAM,GAAW,uDAAuD,CAAC;IACzE,oBAAO,GAAW,eAAe,CAAC;IA6G3D,mBAAC;CAtPD,AAsPC,IAAA;AAtPY,oCAAY","file":"services/toastService/ToastService.js","sourcesContent":["import Guid from '@microsoft/sp-core-library/lib/Guid';\nimport { SPHttpClient, SPHttpClientResponse } from '@microsoft/sp-http';\n\nimport { IToast } from './IToast';\n\ninterface IToastStatus {\n\tId: number;\n\tAck: Date;\n}\n\ninterface IToastCache {\n\tLoaded?: Date;\n\tToasts: IToast[];\n\tToastStatuses: IToastStatus[];\n}\n\n/** Returns items from the Toast list and caches the results */\nexport class ToastService {\n\tprivate static readonly storageKeyBase: string = 'spfxToastr'; //Key used for localStorage\n\tprivate static readonly getFromListAlways: boolean = false; //Useful for testing\n\n\n\t//***********************\n\t//Public Methods\n\t//***********************\n\n\t/** Retrieves toasts that should be displayed for the given user*/\n\tpublic static getToasts(spHttpClient: SPHttpClient, baseUrl: string, webId: Guid): Promise<IToast[]> {\n\t\treturn new Promise<IToast[]>((resolve: (toasts: IToast[]) => void, reject: (error: any) => void): void => {\n\t\t\tthis.ensureToasts(spHttpClient, baseUrl, webId)\n\t\t\t\t.then((toasts: IToast[]): void => {\n\t\t\t\t\tresolve(toasts);\n\t\t\t\t}).catch((error: any): void => {\n\t\t\t\t\treject(error);\n\t\t\t\t});\n\t\t});\n\t}\n\n\t/** Stores the date/time a toast was acknowledged, used to control what shows on the next refresh \n\t * @param {number} id - The list ID of the toast to acknowledge\n\t*/\n\tpublic static acknowledgeToast(id: number, webId: Guid): void {\n\t\tlet cachedData: IToastCache = ToastService.retrieveCache(webId);\n\n\t\t// Check if the status already exists, and if so update it\n\t\t//  otherwise, add a new status for the id\n\t\tlet index: number = ToastService.indexOfToastStatusById(id, cachedData.ToastStatuses);\n\t\tif (index >= 0) {\n\t\t\tcachedData.ToastStatuses[index].Ack = new Date();\n\t\t} else {\n\t\t\tcachedData.ToastStatuses.push({\n\t\t\t\tId: id,\n\t\t\t\tAck: new Date()\n\t\t\t});\n\t\t}\n\t\tToastService.storeCache(cachedData, webId);\n\t}\n\n\t\n\t//***********************\n\t//localStorage Management\n\t//***********************\n\n\tprivate static webStorageKey(webId: Guid): string {\n\t\treturn `${ToastService.storageKeyBase}_${webId}`;\n\t}\n\n\t/** Rehydrates spfxToastr data from localStorage (or creates a new empty set) */\n\tprivate static retrieveCache(webId: Guid): IToastCache {\n\t\t//Pull data from localStorage if available and we previously cached it\n\t\tlet cachedData: IToastCache = localStorage ? JSON.parse(localStorage.getItem(this.webStorageKey(webId))) : undefined;\n\t\tif (cachedData) {\n\t\t\tcachedData.Loaded = new Date(cachedData.Loaded.valueOf()); //Rehydrate date from JSON (serializes to string)\n\t\t} else {\n\t\t\t//Initialize a new, empty object\n\t\t\tcachedData = {\n\t\t\t\tToasts: [],\n\t\t\t\tToastStatuses: []\n\t\t\t};\n\t\t}\n\t\treturn cachedData;\n\t}\n\n\t/** Serializes spfxToastr data into localStorage */\n\tprivate static storeCache(cachedData: IToastCache, webId: Guid): void {\n\t\t//Cache the data in localStorage when possible\n\t\tif (localStorage) {\n\t\t\tlocalStorage.setItem(this.webStorageKey(webId), JSON.stringify(cachedData));\n\t\t}\n\t}\n\n\n\t//***********************\n\t//Toast Retrieval\n\t//***********************\n\n\t/** Retrieves toasts from either the cache or the list depending on the cache's freshness */\n\tprivate static ensureToasts(spHttpClient: SPHttpClient, baseUrl: string, webId: Guid): Promise<IToast[]> {\n\t\treturn new Promise<IToast[]>((resolve: (toasts: IToast[]) => void, reject: (error: any) => void): void => {\n\t\t\t\n\t\t\tlet cachedData: IToastCache = ToastService.retrieveCache(webId);\n\n\t\t\tif(cachedData.Loaded) {\n\t\t\t\t//True Cache found, check if it is stale\n\t\t\t\t// anything older than 2 minutes will be considered stale\n\t\t\t\tlet now: Date = new Date();\n\t\t\t\tlet staleTime: Date = new Date(now.getTime() + -2*60000);\n\n\t\t\t\tif (cachedData.Loaded > staleTime && !ToastService.getFromListAlways) {\n\t\t\t\t\t//console.log('Pulled toasts from localStorage');\n\t\t\t\t\tresolve(ToastService.reduceToasts(cachedData));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((window as any).spfxToastrLoadingData) {\n\t\t\t\t//Toasts are already being loaded! Briefly wait and try again\n\t\t\t\twindow.setTimeout((): void => {\n\t\t\t\t\tToastService.ensureToasts(spHttpClient, baseUrl, webId)\n\t\t\t\t\t\t.then((toasts: IToast[]): void => {\n\t\t\t\t\t\t\tresolve(toasts);\n\t\t\t\t\t\t});\n\t\t\t\t}, 100);\n\t\t\t} else {\n\t\t\t\t//Set a loading flag to prevent multiple data queries from firing\n\t\t\t\t//  this will be important should there be multiple consumers of the service on a single page\n\t\t\t\t(window as any).spfxToastrLoadingData = true;\n\n\t\t\t\t//Toasts need to be loaded, so let's go get them!\n\t\t\t\tToastService.getToastsFromList(spHttpClient, baseUrl)\n\t\t\t\t\t.then((toasts: IToast[]): void => {\n\t\t\t\t\t\t//console.log('Pulled toasts from the list');\n\t\t\t\t\t\tcachedData.Toasts = toasts;\n\t\t\t\t\t\tcachedData.Loaded = new Date(); //Reset the cache timeout\n\t\t\t\t\t\tcachedData = ToastService.processCache(cachedData);\n\n\t\t\t\t\t\t//Update the cache\n\t\t\t\t\t\tToastService.storeCache(cachedData, webId);\n\n\t\t\t\t\t\t//Clear the loading flag\n\t\t\t\t\t\t(window as any).spfxToastrLoadingData = false;\n\n\t\t\t\t\t\t//Give them some toast!\n\t\t\t\t\t\tresolve(ToastService.reduceToasts(cachedData));\n\t\t\t\t\t}).catch((error: any): void => {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t//Breaking up the URL like this isn't necessary, but can be easier to update\n\tprivate static readonly apiEndPoint: string = \"_api/web/lists/getbytitle('Toast')/items\";\n\tprivate static readonly select: string = \"Id,Title,Severity,Frequency,Enabled,Message,Link,Demo\";\n\tprivate static readonly orderby: string = \"StartDate asc\";\n\n\t/** Pulls the active toast entries directly from the underlying list */\n\tprivate static getToastsFromList(spHttpClient: SPHttpClient, baseUrl: string): Promise<IToast[]> {\n\t\t//Toasts are only shown during their scheduled window\n\t\tlet now: string = new Date().toISOString();\n\t\tlet filter: string = `(StartDate le datetime'${now}') and (EndDate ge datetime'${now}')`;\n\t\t\n\t\treturn spHttpClient.get(`${baseUrl}/${ToastService.apiEndPoint}?$select=${ToastService.select}&$filter=${filter}&$orderby=${ToastService.orderby}`,SPHttpClient.configurations.v1)\n\t\t\t.then((response: SPHttpClientResponse): Promise<{ value: IToast[] }> => {\n\t\t\t\t\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\t//Failed requests don't automatically throw exceptions which\n\t\t\t\t\t// can be problematic for chained promises, so we throw one\n\t\t\t\t\tthrow `Unable to get items: ${response.status} (${response.statusText})`;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn response.json();\n\t\t\t})\n\t\t\t.then((results: {value: IToast[]}) => {\n\t\t\t\t//Clean up extra properties\n\t\t\t\t// Even when your interface only defines certain properties, SP sends many\n\t\t\t\t// extra properties that you may or may not care about (we don't)\n\t\t\t\t// (this isn't strictly necessary but makes the cache much cleaner)\n\t\t\t\tlet toasts:IToast[] = [];\n\t\t\t\tfor (let v of results.value) {\n\t\t\n\t\t\t\t\ttoasts.push({\n\t\t\t\t\t\tTitle: v.Title,\n\t\t\t\t\t\tId: v.Id,\n\t\t\t\t\t\tSeverity: v.Severity,\n\t\t\t\t\t\tFrequency: v.Frequency,\n\t\t\t\t\t\tEnabled: v.Enabled,\n\t\t\t\t\t\tMessage: v.Message+`<div></div>`,\n\t\t\t\t\t\tDemo:v.Demo\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn toasts;\n\t\t\t});\n\t}\n\n\n\t//***********************\n\t//Helper Functions\n\t//***********************\n\n\t/** Helper function to return the index of an IToastStatus object by the Id property */\n\tprivate static indexOfToastStatusById(Id: number, toastStatuses: IToastStatus[]): number {\n\t\tfor (let i: number = 0; i < toastStatuses.length; i++) {\n\t\t\tif (toastStatuses[i].Id == Id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/** Helper function to clean up the toast statuses by removing old toasts */\n\tprivate static processCache(cachedData: IToastCache): IToastCache {\n\t\t//Setup a temporary array of Ids (makes the filtering easier)\n\t\tlet activeIds: number[] = [];\n\t\tfor (let toast of cachedData.Toasts) {\n\t\t\tactiveIds.push(toast.Id);\n\t\t}\n\n\t\t//only keep the status info for toast that still matter (active)\n\t\tcachedData.ToastStatuses = cachedData.ToastStatuses.filter((value: IToastStatus): boolean => {\n\t\t\treturn activeIds.indexOf(value.Id) >= 0;\n\t\t});\n\n\t\treturn cachedData;\n\t}\n\n\t/** Adjusts the toasts to display based on what the user has already acknowledged and the toast's frequency value*/\n\tprivate static reduceToasts(cachedData: IToastCache): IToast[] {\n\t\treturn cachedData.Toasts.filter((toast: IToast): boolean => {\n\t\t\tif (!toast.Enabled) {\n\t\t\t\t//Disabled toasts are still queried so that their status isn't lost\n\t\t\t\t// however, they shouldn't be displayed\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlet tsIndex: number = ToastService.indexOfToastStatusById(toast.Id, cachedData.ToastStatuses);\n\t\t\tif (tsIndex >= 0) {\n\t\t\t\tlet lastShown: Date = new Date(cachedData.ToastStatuses[tsIndex].Ack.valueOf()); //Likely needs to be rehyrdated from JSON\n\t\t\t\tswitch (toast.Frequency) {\n\t\t\t\t\tcase 'Once':\n\t\t\t\t\t\t//Already shown\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tcase 'Always':\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t//Default behavior is Once Per Day\n\t\t\t\t\t\tlet now: Date = new Date();\n\t\t\t\t\t\tif (now.getFullYear() !== lastShown.getFullYear()\n\t\t\t\t\t\t\t\t|| now.getMonth() !== lastShown.getMonth()\n\t\t\t\t\t\t\t\t|| now.getDay() !== lastShown.getDay()) {\n\t\t\t\t\t\t\t//Last shown on a different day, so show it!\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//Already shown today\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//No previous status means it needs to be shown\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t}\n}"],"sourceRoot":"..\\..\\..\\src"}